/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.crashtestdummy;

import java.util.ArrayList;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import android.os.Handler;
import android.os.Looper;

import java.lang.Thread;
import java.util.concurrent.locks.*;

@Kroll.module(name="Crashtestdummyandroid", id="ti.crashtestdummy")
public class CrashtestdummyandroidModule extends KrollModule
{

	// Standard Debugging variables
	private static final String LCAT = "CrashtestdummyandroidModule";
	private static final boolean DBG = TiConfig.LOGD;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	private ArrayList<Object> storage;
	
	public CrashtestdummyandroidModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Log.d(LCAT, "inside onAppCreate with crashtestdummy.jni");
		System.loadLibrary("ti.crashtestdummy.jni");
		// put module init code that needs to run when the application is created
	}

	// Methods
	/*
	 *	Usage: This is to slowly leak memory, as storage never stops holding onto its contents.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.addToStorage("Store me!");
	 */
	@Kroll.method
	public void addToStorage(Object... args)
	{
		Log.d(LCAT,"Adding " + args.toString() + " to storage in thread " + Thread.currentThread().toString());
		storage.add(args);
	}
	
	/*
	 *	Usage: This is to quickly leak memory, as we enter an infinite loop to fill storage.
	 *	This is to spur a memory panic and then force kill from the OS.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.consumeMemory();
	 */
	@Kroll.method
	public void consumeMemory(Object... args)
	{
		Log.d(LCAT,"Preparing to infinite loop and allocate memory in thread " + Thread.currentThread().toString());
		int counter = 0;
		while(true){
			storage.add(new Integer(counter++));
		}
	}

	/*
	 *	Usage: This is to lock twice, never recovering.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.deadlock();
	 */
	@Kroll.method
	public void deadlock(Object... args)
	{
		Log.d(LCAT,"Preparing to deadlock in thread " + Thread.currentThread().toString());
		ReentrantLock deadLock = new ReentrantLock();
		Condition firstCondition = deadLock.newCondition();
		Condition secondCondition = deadLock.newCondition();
		deadLock.lock();
		firstCondition.awaitUninterruptibly();
		secondCondition.awaitUninterruptibly();		
	}

	/*
	 *	Usage: This is to infinite loop, never recovering.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.infiniteLoop();
	 */
	@Kroll.method
	public void infiniteLoop(Object... args)
	{
		Log.d(LCAT,"Preparing to infinite loop in thread " + Thread.currentThread().toString());
		int counter = 0;
		while(true){
			counter ++;
			counter --;
		}
	}

	private native Object nativeBadMemory();
	private native Object nativeOverReleaseMemory();

	/*
	 *	Usage: This is to create a hard crash, by way of a segfault when we dereference a bad pointer.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.accessBadMemory();
	 */
	@Kroll.method
	public void accessBadMemory(Object... args)
	{
		Log.d(LCAT,"Preparing to release a bad memory location in thread " + Thread.currentThread().toString());
		Log.d(LCAT,"This should be crashing:" + nativeBadMemory().toString());
	}

	/*
	 *	Usage: This is to create a hard crash, by way of a segfault when we overrelease memory.
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.overReleaseMemory();
	 */ 
	@Kroll.method
	public void overReleaseMemory(Object... args)
	{
		Log.d(LCAT,"Preparing to over release memory in thread " + Thread.currentThread().toString());
		Log.d(LCAT,"This should be crashing:" + nativeOverReleaseMemory().toString());
	}

	/*
	 *	Usage: This is to throw an exception
	 *	var ctd = require('ti.crashtestdummy');
	 *	ctd.throwException();
	 */
	@Kroll.method
	public void throwException(Object... args)
	{
		Log.d(LCAT,"Preparing to throw exception in thread " + Thread.currentThread().toString());

		String smallArray[] = new String[2];
		String badString = smallArray[10];
	}

	private class performMethod implements Runnable
	{
		public CrashtestdummyandroidModule module;
		public String methodName;
		
		public performMethod(CrashtestdummyandroidModule thisModule, String newMethod, Object... newArgs) {
			module = thisModule;
			methodName = newMethod;
		}
		
		public void run() {
			if (methodName.equals("consumeMemory")) {
				module.consumeMemory();
				return;
			}
			if (methodName.equals("deadlock")) {
				module.deadlock();
				return;
			}
			if (methodName.equals("infiniteLoop")) {
				module.infiniteLoop();
				return;
			}
			if (methodName.equals("accessBadMemory")) {
				module.accessBadMemory();
				return;
			}
			if (methodName.equals("overReleaseMemory")) {
				module.overReleaseMemory();
				return;
			}
			if (methodName.equals("throwException")) {
				module.throwException();
				return;
			}
		}
	}
	
	
	/*
	 *	Usage: This is for parity with the iOS version, which has a mechanism
	 *	to call code with protection against exceptions.
	 */
	@Kroll.method
	public void fireInMainThreadUsingTitanium(String methodName, Object... args)
	{
		Log.d(LCAT,"Android does not have a safe handling. Using fireInMainThreadUsingNative instead");
		fireInMainThreadUsingNative(methodName, args);
	}

	/*
	 *	Usage: This is to invoke another method in the main thread within Titanium's structure
	 *	The first arguement is the name of the method to call,
	 *	var ctd = require('ti.crashtestdummy');
	 *	try {
	 *		ctd.fireInMainThreadUsingNative('throwException'); //Should crash app.
	 *	} catch (e) {}
	 *	ctd.fireInMainThreadUsingNative('deadlock'); //Should lock up UI.
	 */
	@Kroll.method
	public void fireInMainThreadUsingNative(String methodName, Object... args)
	{
		performMethod fireTask = new performMethod(this,methodName,args);
		Handler handler = new Handler(Looper.getMainLooper());
		handler.post(fireTask);
	}

	
	
	/*
	 *	Usage: This is to invoke another method in the main thread within Titanium's structure
	 *	The first arguement is the name of the method to call,
	 *	var ctd = require('ti.crashtestdummy');
	 *	try {
	 *		ctd.fireInBackgroundThreadUsingNative('throwException'); //Should crash app.
	 *	} catch (e) {}
	 *	ctd.fireInBackgroundThreadUsingNative('deadlock'); //Should cause the app to be force killed on background.
	 */
	@Kroll.method
	public void fireInBackgroundThreadUsingNative(String methodName, Object... args)
	{
		performMethod fireTask = new performMethod(this,methodName,args);
		Thread backgroundThread = new Thread(fireTask);
		backgroundThread.start();
	}

}

